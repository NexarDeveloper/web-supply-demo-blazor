schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

scalar Map

scalar Time

type Query {
  node(id: ID!): Node
  desWorkspaces(where: DesWorkspaceFilterInput): [DesWorkspace!]!
  desWorkspaceById(id: String!): DesWorkspace
  desProjects(workspaceUrl: String! where: DesProjectFilterInput): [DesProject!]!
  desProjectById(id: ID!): DesProject
  desAuthorizeByCredentials(username: String! password: String!): DesAuthorizationToken!
  desTechnicalQueryTitle(workspaceUrl: String! processId: String!): String!
  desTechnicalQueryIssue(workspaceUrl: String! processInstanceId: String!): DesTechnicalQueryIssue!
  desWorkflowDefinitions(workspaceUrl: String! where: DesWorkflowDefinitionFilterInput): [DesWorkflowDefinition!]!
  desWorkflows(workspaceUrl: String! where: DesWorkflowFilterInput): [DesWorkflow!]!
  desComponentSearch(workspaceUrl: String! start: Int! limit: Int! text: String tagNames: [String!] orderBy: String): DesSearchResponse!
  desComponentDetails(workspaceUrl: String! revisionGuid: String!): DesDetailsViewModel!
  desComponentOctopartUrl(workspaceUrl: String! revisionGuid: String!): String!
  desComponentTags(workspaceUrl: String!): [DesTag!]!
  desCommentThreads(projectId: ID!): [DesCommentThread!]!
  desCommentThread(projectId: ID! threadId: String!): DesCommentThread
  desUsers(workspaceUrl: String! ids: [String!]!): [DesUser]!
  "Get all attributes"
  supAttributes: [SupAttribute!]!
  "Get manufacturer companies"
  supManufacturers("list of company IDs.  Omit to fetch all manufacturers." ids: [String!]): [SupCompany!]!
  "Get seller companies (distributors)"
  supSellers("list of company IDs.  Omit to fetch all sellers." ids: [String!]): [SupCompany!]!
  "Get categories"
  supCategories("list of category IDs. Omit to fetch all categories." ids: [String!] "list of \/electronic-parts SEO page paths for categories." paths: [String!]): [SupCategory!]!
  "Get parts by ID."
  supParts("list of part IDs. APIv3 UIDs are also supported." ids: [String!]! "user's country" country: String! = "US" "user's currency" currency: String! = "USD" "fetch latest pricing and stock data from distributor API. Company.isDistributorApi indicates if a distributor supports this feature." distributorApi: Boolean "how long to wait for distributor API to respond as a duration string (e.g. `3s` or `500ms`)" distributorApiTimeout: String! = "3s" "if needed, pass along credentials for API integrations" customPricingCredentials: [SupApiCredentials!]): [SupPart]!
  "Attempt to complete a partial query string.  Used for autosuggest \/ typeahead text inputs."
  supSuggest("partial query string" q: String! "categoryId to scope suggestions to" categoryId: String "only return part number suggestions" partNumbersOnly: Boolean): [SupSuggestion!]!
  "Search parts, including filters, pagination, aggregation, sorting"
  supSearch("the query to search" q: String "user's country" country: String! = "US" "user's currency" currency: String! = "USD" "offset in the result set" start: Int "page size of results" limit: Int "field to sort by.  See [sort values](\/api\/v4\/values#sort)" sort: String "direction of sort: `asc` or `desc`" sortDir: SupSortDirection "filter to remove parts with no stocking distributors" inStockOnly: Boolean "a key: value map of filters. See [filter values](\/api\/v4\/values#filters)" filters: Map "fetch latest pricing and stock data from distributor API. Company.isDistributorApi indicates if a distributor supports this feature." distributorApi: Boolean "how long to wait for distributor API to respond as a duration string (e.g. `3s` or `500ms`)" distributorApiTimeout: String! = "3s" "if needed, pass along credentials for API integrations" customPricingCredentials: [SupApiCredentials!]): SupPartResultSet!
  "Suggest an alternate `q` when no results are found"
  supSpellingCorrection("query string to correct" q: String!): [SupSpellingCorrection!]!
  "Match multiple manufacturer + mpn pairs at once.  Useful for when you have a list of parts, as with a BOM (Bill of Materials)"
  supMultiMatch("list of inputs to attempt to match" queries: [SupPartMatchQuery!]! "options when matching such as applying filters or only including authorized or in-stock parts" options: SupPartMatchOptions "user's country" country: String! = "US" "user's currency" currency: String! = "USD" "fetch latest pricing and stock data from distributor API. Company.isDistributorApi indicates if a distributor supports this feature." distributorApi: Boolean "how long to wait for distributor API to respond as a duration string (e.g. `3s` or `500ms`)" distributorApiTimeout: String! = "3s" "if needed, pass along credentials for API integrations" customPricingCredentials: [SupApiCredentials!]): [SupPartMatch!]!
}

type Mutation {
  desCreateComment(input: DesCreateCommentInput!): DesCreateCommentPayload!
  desDeleteComment(input: DesDeleteCommentInput!): DesDeleteCommentPayload!
  desUpdateComment(input: DesUpdateCommentInput!): DesUpdateCommentPayload!
  desCreateCommentThread(input: DesCreateCommentThreadInput!): DesCreateCommentThreadPayload!
  desDeleteCommentThread(input: DesDeleteCommentThreadInput!): DesDeleteCommentThreadPayload!
  desCreateTechnicalQueryIssue(input: DesCreateTechnicalQueryIssueInput!): DesCreateTechnicalQueryIssuePayload!
}

type Subscription {
  desOnCommentUpdated(input: DesOnCommentUpdatedInput!): DesCommentNotification!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

type DesAuthorizationToken {
  token: String!
}

type DesBOMItem {
  createdAt: DateTime!
  createdByGuid: String!
  guid: String!
  deleted: Boolean!
  itemGuid: String!
  revisionStatus: Int!
  bomItemInstances: [DesBOMItemInstance!]!
  baseComponent: DesBaseComponent!
  quantity: Int!
}

type DesBOMItemInstance {
  createdAt: DateTime!
  createdByGuid: String!
  guid: String!
  deleted: Boolean!
  itemGuid: String!
  revisionStatus: Int!
  designator: String!
  isFitted: Boolean!
}

type DesBOMRoot {
  assemblyVariantRevisionGuid: String!
  bomGuid: String!
  bomItems: [DesBOMItem!]!
  locked: Boolean!
  version: String!
}

type DesBaseComponent {
  createdAt: DateTime!
  createdByGuid: String!
  guid: String!
  deleted: Boolean!
  itemGuid: String!
  revisionStatus: Int!
  comment: String!
  description: String!
  folderGuid: String!
  manufacturerComponents: [DesManufacturerComponent!]!
  parameters: [DesParameter!]!
  partNumber: String!
  revision: String!
}

type DesBoundingBox {
  x1: Int!
  y1: Int!
  x2: Int!
  y2: Int!
}

type DesComment {
  guid: String!
  text: String!
  createdBy: String!
  mentions: [DesMention!]!
}

type DesCommentNotification {
  action: String!
  data: DesCommentNotificationData!
}

type DesCommentNotificationData {
  projectGUID: String!
  documentID: String
  documentNAME: String
  threadGUID: String!
  threadDATE: String!
  threadDATA: String
  threadSTATUS: String
  commentGUID: String!
  commentAUTHOR: String
  commentDATE: String!
  commentTEXT: String
}

type DesCommentThread {
  guid: String!
  data: String!
  assignedTo: String
  createdAt: DateTime!
  createdBy: String!
  drawing: String
  modifiedAt: DateTime!
  modifiedBy: String!
  originalStateScreenshotUrl: String
  status: Int!
  threadNumber: Int!
  comments: [DesComment!]!
}

type DesCompParameter {
  at: Int!
  name: String!
  value: String!
}

type DesCompVariationParameter {
  name: String!
  value: String!
}

type DesComponent {
  designator: String!
  comment: String!
  footprintName: String!
  description: String!
  pcbLocationX: Int!
  pcbLocationY: Int!
  boundRect: [Int!]!
  layerName: String!
  primitives: [Int!]!
  parameters: [DesCompParameter!]!
  designItemId: String!
  kind: Int!
  pcbId: Int!
  pcbUniqueId: String!
  layerId: Int!
  schId: String!
  schDocId: String!
}

type DesComponentVariation {
  uniqueId: String!
  pcbId: Int!
  variationKind: Int!
  parameters: [DesCompVariationParameter!]!
  physicalDesignator: String!
  parts: [DesPart!]!
}

type DesCreateCommentPayload {
  guid: String!
  error: DesUserError
}

type DesCreateCommentThreadPayload {
  threadGuid: String!
  commentGuid: String!
  error: DesUserError
}

type DesCreateTechnicalQueryIssuePayload {
  status: Int!
  id: String!
  definitionId: String!
  title: String!
  ended: Boolean!
  suspended: Boolean!
  error: DesUserError
}

type DesDebugInfo {
  facetFieldNames: [String]
}

type DesDeleteCommentPayload {
  error: DesUserError
}

type DesDeleteCommentThreadPayload {
  error: DesUserError
}

type DesDesign {
  pcbDesign: DesDesignRoot
  bom: DesBOMRoot
  commentThreads: [DesCommentThread!]!
}

type DesDesignRoot {
  version: String!
  pcbDocument: DesPcbDocument!
  schDocuments: [DesSchDocument!]!
  layers: [DesLayer!]!
  components: [DesComponent!]!
  nets: [DesNet!]!
  primitives: [DesPrimitive!]!
  projectVariants: [DesProjectVariant!]!
  alternatePartsRaw: String!
  projectTypeName: String!
}

type DesDetailsViewModel {
  componentRevision: DesRevision
  symbols: [DesRevision]
  footprints: [DesRevision]
  whereUsedRevisions: [DesWhereUsedRevision]
  whereUsedTotalCount: Int!
  isAllParentsAccessible: Boolean!
  references: [DesItemReference]
  manufLifeCycleStatusId: Int!
  manufLifeCycleStatusName: String
  stock: Decimal!
  medianPrice: String
}

type DesDtoDocumentField {
  name: String
  value: String
  fieldType: DesDtoFieldType!
  offsets: [DesDtoDocumentFieldOffset]
}

type DesDtoDocumentFieldOffset {
  offset: Int!
  length: Int!
}

type DesDtoFacet {
  facetName: String
  totalHitCount: Long!
  counters: [DesDtoFacetCounter]
  supportRange: Boolean!
  minValue: String
  maxValue: String
}

type DesDtoFacetCounter {
  value: String
  count: Long!
}

type DesDtoScoredDocument {
  score: Float!
  fields: [DesDtoDocumentField]
}

type DesItemReference {
  caption: String
  fileName: String
  url: String
}

type DesKeyValuePairOfStringAndString {
  key: String!
  value: String!
}

type DesLayer {
  id: Int!
  name: String!
  searchName: String!
  color: String!
  kind: Int!
  stackIndex: Int!
}

type DesManufacturerComponent {
  createdAt: DateTime!
  createdByGuid: String!
  guid: String!
  deleted: Boolean!
  itemGuid: String!
  revisionStatus: Int!
  bomLinkStatus: Int!
  ciivaID: Int!
  libraryLinkStatus: Int!
  name: String!
  partNumber: String!
  priority: Int!
  supplierComponents: [DesSupplierComponent!]!
}

type DesMention {
  mentionGuid: String!
  mentionType: Int!
}

type DesNet {
  name: String!
  layersUsed: [Int!]!
  length: Int!
  primitives: [Int!]!
}

type DesParameter {
  createdAt: DateTime!
  createdByGuid: String!
  guid: String!
  deleted: Boolean!
  revisionStatus: Int!
  parameterKey: String!
  parameterUnitGuid: String!
  parameterValue: String!
}

type DesPart {
  uniqueId: String!
  designator: String!
  x: Int!
  y: Int!
  identifierString: String!
  orientation: Int!
  physicalDesignator: String!
  boundingBox: DesBoundingBox!
  isMirrored: Boolean!
}

type DesPcbDocument {
  horizontal: Float!
  vertical: Float!
  fileName: String!
  id: String!
  order: Int!
  originX: Int!
  originY: Int!
  units: Int!
  area: Float!
  version: String
}

type DesPrimitive {
  docLink: String
  id: Int
  kind: Int
  schId: String
  schDocId: String
  width: Int
  radius: Int
  x: Int
  y: Int
  pcbId: Int
  layerId: Int
  name: String
  fullName: String
  holeSize: Int
  shape: Int
  shapeSizeX: Int
  shapeSizeY: Int
  plated: Boolean
  pcbUniqueId: String
}

type DesProject implements Node {
  id: ID!
  createdBy: DesUser
  updatedBy: DesUser
  parameters(where: DesProjectParameterFilterInput): [DesProjectParameter!]!
  releases: [String!]!
  projectId: String!
  name: String
  description: String
  createdAt: DateTime
  updatedAt: DateTime
  design: DesDesign!
}

type DesProjectParameter {
  name: String!
  value: String!
}

type DesProjectVariant {
  uniqueId: String!
  name: String!
  graphite: [Int!]
  order: Int!
  componentVariations: [DesComponentVariation!]!
}

type DesRevision {
  guid: String
  hrid: String
  itemHrid: String
  description: String
  revisionStateColor: String
  revisionStateText: String
  parameters: [DesKeyValuePairOfStringAndString!]
  imgPreviewUrlSm: String
  imgPreviewUrlMd: String
}

type DesSchDocument {
  id: String!
  parentIds: [String!]!
  fileName: String!
  order: Int!
  units: Int!
}

type DesSearchResponse {
  documents: [DesDtoScoredDocument]
  facetedCounters: [DesDtoFacet]
  total: Int!
  debug: DesDebugInfo
  success: Boolean!
  error: String
}

type DesSupplierComponent {
  createdAt: DateTime!
  createdByGuid: String!
  guid: String!
  deleted: Boolean!
  itemGuid: String!
  revisionStatus: Int!
  bOMLinkStatus: Int!
  ciivaID: Int!
  libraryLinkStatus: Int!
  name: String!
  partNumber: String!
  priority: Int!
}

type DesTag {
  guid: String
  name: String
  originalName: String
  parentGuid: String
  subTags: [DesTag]
  count: Int!
  subTagNames: [String]
}

type DesTechnicalQueryIssue {
  id: String!
  parentActivityInstanceId: String
  activityId: String!
  activityType: String!
  processInstanceId: String!
  processDefinitionId: String!
  state: String!
  executionIds: [String!]!
  activityName: String
  name: String
  error: DesUserError
}

type DesUpdateCommentPayload {
  error: DesUserError
}

type DesUser {
  userId: String!
  userName: String!
  email: String!
  fullName: String!
}

type DesUserError {
  code: String!
  message: String!
}

type DesVariable {
  name: String!
  valueType: String!
  value: String!
}

type DesWhereUsedRevision {
  explorerUrl: String
  date: DateTime!
  guid: String
  hrid: String
  itemHrid: String
  description: String
  revisionStateColor: String
  revisionStateText: String
  parameters: [DesKeyValuePairOfStringAndString!]
  imgPreviewUrlSm: String
  imgPreviewUrlMd: String
}

type DesWorkflow {
  variables(where: DesVariableFilterInput): [DesVariable!]!
  id: String
  suspended: Boolean!
  state: String
  assignee: String
  createdBy: String
  createdAt: DateTime!
  endedAt: DateTime
  businessKey: String
  processDefinitionId: String
  processDefinitionName: String
  versionTag: String
  status: String
}

type DesWorkflowDefinition {
  id: String
  name: String
  version: Int!
  latestVersion: Boolean!
  suspended: Boolean!
  state: String
  createdBy: String
  createdAt: DateTime!
}

type DesWorkspace implements Node {
  id: ID!
  projects(where: DesProjectFilterInput): [DesProject!]!
  name: String!
  url: String!
  workspaceId: String!
  description: String
}

input DesBooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input DesComparableDateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime!]
  nin: [DateTime!]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input DesComparableInt32OperationFilterInput {
  eq: Int
  neq: Int
  in: [Int!]
  nin: [Int!]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input DesComparableNullableOfDateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input DesCreateCommentInput {
  entityId: ID!
  threadGuid: String!
  text: String!
}

input DesCreateCommentThreadInput {
  entityId: ID!
  data: String!
  text: String!
}

input DesCreateTechnicalQueryIssueInput {
  workspaceUrl: String!
  processId: String!
  projectId: String!
  title: String!
  description: String!
  priority: String!
  coordinator: String
}

input DesDeleteCommentInput {
  entityId: ID!
  threadGuid: String!
  commentGuid: String!
}

input DesDeleteCommentThreadInput {
  entityId: ID!
  threadGuid: String!
}

input DesDesignFilterInput {
  and: [DesDesignFilterInput!]
  or: [DesDesignFilterInput!]
}

input DesOnCommentUpdatedInput {
  workspaceUrl: String!
  token: String!
}

input DesProjectFilterInput {
  and: [DesProjectFilterInput!]
  or: [DesProjectFilterInput!]
  id: DesStringOperationFilterInput
  projectId: DesStringOperationFilterInput
  name: DesStringOperationFilterInput
  description: DesStringOperationFilterInput
  createdAt: DesComparableNullableOfDateTimeOperationFilterInput
  updatedAt: DesComparableNullableOfDateTimeOperationFilterInput
  design: DesDesignFilterInput
}

input DesProjectParameterFilterInput {
  and: [DesProjectParameterFilterInput!]
  or: [DesProjectParameterFilterInput!]
  name: DesStringOperationFilterInput
  value: DesStringOperationFilterInput
}

input DesStringOperationFilterInput {
  and: [DesStringOperationFilterInput!]
  or: [DesStringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input DesUpdateCommentInput {
  entityId: ID!
  threadGuid: String!
  commentGuid: String!
  text: String!
}

input DesVariableFilterInput {
  and: [DesVariableFilterInput!]
  or: [DesVariableFilterInput!]
  name: DesStringOperationFilterInput
  valueType: DesStringOperationFilterInput
  value: DesStringOperationFilterInput
}

input DesWorkflowDefinitionFilterInput {
  and: [DesWorkflowDefinitionFilterInput!]
  or: [DesWorkflowDefinitionFilterInput!]
  id: DesStringOperationFilterInput
  name: DesStringOperationFilterInput
  version: DesComparableInt32OperationFilterInput
  latestVersion: DesBooleanOperationFilterInput
  suspended: DesBooleanOperationFilterInput
  state: DesStringOperationFilterInput
  createdBy: DesStringOperationFilterInput
  createdAt: DesComparableDateTimeOperationFilterInput
}

input DesWorkflowFilterInput {
  and: [DesWorkflowFilterInput!]
  or: [DesWorkflowFilterInput!]
  id: DesStringOperationFilterInput
  suspended: DesBooleanOperationFilterInput
  state: DesStringOperationFilterInput
  assignee: DesStringOperationFilterInput
  createdBy: DesStringOperationFilterInput
  createdAt: DesComparableDateTimeOperationFilterInput
  endedAt: DesComparableNullableOfDateTimeOperationFilterInput
  businessKey: DesStringOperationFilterInput
  processDefinitionId: DesStringOperationFilterInput
  processDefinitionName: DesStringOperationFilterInput
  versionTag: DesStringOperationFilterInput
  status: DesStringOperationFilterInput
}

input DesWorkspaceFilterInput {
  and: [DesWorkspaceFilterInput!]
  or: [DesWorkspaceFilterInput!]
  id: DesStringOperationFilterInput
  name: DesStringOperationFilterInput
  url: DesStringOperationFilterInput
  workspaceId: DesStringOperationFilterInput
  description: DesStringOperationFilterInput
}

enum DesDtoFieldType {
  INTEGER_TYPE
  DOUBLE_TYPE
  DATE_TIME_TYPE
  TEXT_TYPE
  UNKNOWN
}

"Used to show the filters that are applied to current search."
type SupAppliedFilter {
  "shortname is the key in the filters Map.  Usually an attribute shortname, or `manufacturerId`, `distributorId`, etc."
  shortname: String!
  "human readable name to display in the UI"
  name: String!
  "values in the filter Map."
  values: [String!]!
  "human readable values to display in the UI"
  displayValues: [String!]!
}

"Defines an attribute like Capacitance or Resistance."
type SupAttribute {
  "Internal Octopart ID"
  id: ID!
  "display name"
  name: String!
  "use as key for `sort` or `filter` in part search"
  shortname: String!
  "use to group together similar attributes, e.g. Technical, Physical, Compliance"
  group: String!
}

"Groups similar attributes together, as can be seen with column groups in specs view"
type SupAttributeGroup {
  "Name of group, e.g. Technical, Physical, Compliance"
  name: String!
  "Attributes in group"
  attributes: [SupAttribute!]!
}

"Information for use on \/electronic-parts Category pages."
type SupBlurb {
  "Category name."
  name: String!
  "Path to \/electronic-parts Category page."
  pathName: String!
  "Short description of Category."
  description: String!
  "Longer description of Category."
  content: String!
}

"cadAgg produces a CadBucket with the count of parts that have CAD Symbol + Footprint and 3D model"
type SupCadBucket {
  cadState: String!
  count: Int
}

"A Category exists in a Category tree.  Examples include Passive Components or Capacitors.  The `path` field is helpful to see where a category is in the tree.\nCategory id `4161` is the root of tree."
type SupCategory {
  "Octopart internal id.  Root id is 4161"
  id: ID!
  "ID of parent category."
  parentId: ID!
  "Display name"
  name: String!
  "List of all ancestor in category tree."
  ancestors: [SupCategory!]!
  "List of direct children in category tree."
  children: [SupCategory!]!
  "Slash separated path.  Can be used to visit URL for category page.  (e.g. `\/electronic-parts\/circuit-protection\/esd-and-circuit-protection-ics`)"
  path: String!
  "List of Attributes deemed to be relevant to this category.  (e.g. Resistance for Resistor category).  Useful for showing contextual filters in UI."
  relevantAttributes: [SupAttribute!]!
  "Blurb for Category, used on \/electronic-parts pages."
  blurb: SupBlurb
  "Number of parts in Category."
  numParts: Int!
}

"categoryAgg produces a CategoryBucket with category + counts"
type SupCategoryBucket {
  category: SupCategory!
  count: Int
}

"A company record represents a manufacturer or distributor, depending on context."
type SupCompany {
  "Octopart internal id"
  id: ID!
  "Display name of company"
  name: String!
  "Aliases of company"
  aliases: [String!]!
  "Homepage URL of company"
  homepageUrl: String
  "Used for URLs like `\/manufacturers\/aimtec` or `\/distributors\/digi-key`"
  slug: String!
  "True if a manufacturer participates in Octopart's Verified Manufacturer program.  See [verified](https:\/\/octopart.com\/verified) for more information."
  isVerified: Boolean!
  "True if a distributor is a broker.  See [authorized](https:\/\/octopart.com\/authorized) for more information."
  isBroker: Boolean! @deprecated(reason: "use `PartSeller.is_broker` instead")
  "True if a distributor has an API integration with Octopart to provide latest pricing and stock data."
  isDistributorApi: Boolean!
}

"manufacturerAgg and distributorAgg produce a CompanyBucket with company + counts"
type SupCompanyBucket {
  company: SupCompany!
  count: Int
}

"A country's name, country code, and continent code."
type SupCountry {
  name: String!
  countryCode: String!
  continentCode: String!
}

"Textual description of a part"
type SupDescription {
  "Description text"
  text: String!
  "Source of description.  Used for attribution."
  creditString: String!
  "Source URL of description.  Used for attribution."
  creditUrl: String!
}

"Document represents a PDF file and can be a Datasheet, Compliance Document, PCN, etc."
type SupDocument {
  name: String!
  pageCount: Int
  createdAt: Time
  url: String!
  creditString: String!
  creditUrl: String!
  mimeType: String!
}

"DocumentCollection groups documents together by type: Datasheets, Compliance Statements."
type SupDocumentCollection {
  "Name of group, e.g. Datasheets"
  name: String!
  "List of Documents in group"
  documents: [SupDocument!]!
}

"Image of a part.  In the case of some symbol and footprint images, the scaled version may not actually be scaled and cropped, and may need to be scaled using CSS or other techniques."
type SupImage {
  urlLargest: String! @deprecated(reason: "use `url` instead")
  url55px: String! @deprecated(reason: "use `url` instead")
  url75px: String! @deprecated(reason: "use `url` instead")
  url90px: String! @deprecated(reason: "use `url` instead")
  "Image URL"
  url: String!
  "Source of description.  Used for attribution."
  creditString: String!
  "Source URL of description.  Used for attribution."
  creditUrl: String!
}

"An offer is a specific buyable part from a distributor, with specific packaging, pricing, stock, moq."
type SupOffer {
  "Cache ID"
  _cacheId: String!
  "Octopart internal ID for this offer"
  id: ID!
  "Stock Keeping Unit used by internally by distributor"
  sku: String!
  "Number of units available to be shipped.  (aka Stock, Quantity)"
  inventoryLevel: Int!
  "Packaging of parts (eg Tape, Reel)"
  packaging: String
  "Minimum Order Quantity: smallest number of parts that can be purchased"
  moq: Int
  prices: [SupPricePoint!]!
  "The URL to view offer on distributor website.  This will redirect via Octopart's server."
  clickUrl: String!
  "Octopart internal URL for this offer."
  internalUrl: String!
  "The last time data was received from distributor feed or API for this offer."
  updated: Time!
  "Number of days to acquire parts from factory."
  factoryLeadDays: Int
  "Number of parts on order from factory."
  onOrderQuantity: Int
  "Order multiple for factory orders."
  factoryPackQuantity: Int
  "Number of items which must be ordered together."
  orderMultiple: Int
  "The quantity of parts as packaged by the seller."
  multipackQuantity: Int
  "Whether this offer is specific to the customer making the request."
  isCustomPricing: Boolean!
}

"Part model contains the relevant data around a part, including: datasheets, specs, sellers + offers, images, etc."
type SupPart {
  "Cache ID"
  _cacheId: String!
  "Octopart internal ID for this part.  Appears at the end of PDP URL \/ `slug` field."
  id: ID!
  "manufacturer + mpn for easy display"
  name: String!
  "Manufacturer Part Number"
  mpn: String!
  "Best guess at a generic MPN"
  genericMpn: String!
  "Company that manufactures this part"
  manufacturer: SupCompany!
  "A link to the manufacturer detail page for this part or series."
  manufacturerUrl: String
  "A link to a manufacturer page to request free sample kits for this part."
  freeSampleUrl: String
  "Documents including Datasheets, Compliance Documents, PCNs"
  documentCollections: [SupDocumentCollection!]!
  "Best description around 110 characters long, as can be seen on SERP or PDP.  May need truncation if all descriptions are long."
  shortDescription: String!
  "All part descriptions from sources"
  descriptions: [SupDescription!]!
  "All part images"
  images: [SupImage!]!
  "Attribute values for this part"
  specs: [SupSpec!]!
  "Path component of PDP URL (e.g. `\/ad7792bruz-analog+devices-402798`)"
  slug: String!
  "A link to the part page on Octopart. Do not include `rel=\"nofollow\"` when linking to this URL."
  octopartUrl: String!
  "Parts identified by Octopart to be similar in specs and functionality."
  similarParts: [SupPart!]!
  "Parts identified by the manufacturer as companion products."
  companionProducts: [SupSponsoredPart!]!
  category: SupCategory
  series: SupPartSeries
  bestImage: SupImage
  bestDatasheet: SupDocument
  referenceDesigns: [SupReferenceDesign!]!
  "Data about part's CAD model.  If null `cadRequestUrl` can be used to request a CAD model be made."
  cad: SupPartCad
  "URL to request a CAD model from eeconcierge if a part doesn't already have a CAD model.  Will be null part is not eligible, e.g. a multimeter"
  cadRequestUrl: String
  "The UID from Octopart APIv3.  Provided for backwards compatibility, in general ID should be used."
  v3uid: ID!
  "A [Map](#map) of number of related objects.  Can be used to know the number of `images` or `descriptions` without having to request those related objects."
  counts: Map!
  "The median USD price at quantity 1,000, discarding outliers.  A reasonable estimate of average price for a part."
  medianPrice1000: SupPricePoint
  "Sum of stock available across all distributors"
  totalAvail: Int!
  "The average stock level at each distributor"
  avgAvail: Float!
  "Companies with Offers for this part"
  sellers(includeBrokers: Boolean! = false authorizedOnly: Boolean! = false): [SupPartSeller!]!
  "The estimated factory lead time in days derived from trusted distributor offers."
  estimatedFactoryLeadDays: Int
  "This part might be known by these alternate MPNs"
  akaMpns: [String!]!
}

type SupPartCad {
  "URL to add this part to your Upverter library. Requires an Upverter account."
  addToLibraryUrl: String
  "If true, a STEP model will be included with the tool-specific downloads."
  has3dModel: Boolean!
  hasAltium: Boolean!
  hasEagle: Boolean!
  hasOrcad: Boolean!
  hasKicad: Boolean!
  downloadUrlAltium: String!
  downloadUrlEagle: String!
  downloadUrlOrcad: String!
  downloadUrlKicad: String!
  footprintImageUrl: String
  symbolImageUrl: String
}

type SupPartMatch {
  "Will match `reference` supplied in PartMatchQuery."
  reference: String
  "Number of parts matched"
  hits: Int!
  "Matched parts (may be subset, based on start + limit)"
  parts: [SupPart!]!
  "Possible error message"
  error: String
}

type SupPartResult {
  "Cache ID"
  _cacheId: String!
  "The part object"
  part: SupPart!
  explain: String! @deprecated(reason: "always empty")
  "If the search `q` is an alternate MPN for this part, the `akaMpn` will be populated with this alternate MPN."
  akaMpn: String
  "Description with query terms highlighted.  Often this is the same as part.shortDescription,\nbut if the search `q` matched on a different description it may be longer than part.shortDescription and require truncation."
  description: String!
}

"Result of part search."
type SupPartResultSet {
  total: Int! @deprecated(reason: "use `hits` instead")
  "Number of parts in result set"
  hits: Int!
  "Contains nested part along side some fields specific to the query that explain reason for match."
  results: [SupPartResult!]
  "Grouped attributes used to render the columns in specs view."
  specsViewAttributeGroups: [SupAttributeGroup!]!
  "If an invalid query was modified or rejected, warnings indicate this fact to the user.  For example if query contained too many tokens, some tokens may be ignored."
  warnings: [String!]
  "Perform aggregations on Spec values across multiple Attributes.\nYou *must* specify `attributeNames` for this field to be populated.\n`attributeNames` should be a list of Attribute.shortname values (e.g. `capacitance` or `voltageRatingDc`)"
  specAggs("a list of Attribute.shortname values to aggregate on (e.g. `capacitance` or `voltageRatingDc`)" attributeNames: [String!]! "number of spec value buckets to return (default 10)" size: Int! = 10): [SupSpecAgg!]!
  "Aggregate on manufacturers for this result set"
  manufacturerAgg("number of buckets to return (default 10)" size: Int! = 10): [SupCompanyBucket!]!
  "Aggregate on distributors for this result set"
  distributorAgg("number of buckets to return (default 10)" size: Int! = 10): [SupCompanyBucket!]!
  "Aggregate on categories for this result set"
  categoryAgg("number of buckets to return (default 10)" size: Int! = 10): [SupCategoryBucket!]!
  "Aggregate on the availability of CAD models for the result set"
  cadAgg: [SupCadBucket!]!
  "Categories that are determined by search algo to be related to the search term.  Useful for suggesting a Category filter in the search UI."
  suggestedCategories: [SupCategoryBucket!]!
  "Attributes that are determined by search algo to be related to the search term.  Useful for suggesting most relevant filters in the search UI."
  suggestedFilters: [SupAttribute!]!
  "Full list of available Attributes in the result set"
  allFilters: [SupAttribute!]!
  "If a Category filter is applied, this will be the Category"
  appliedCategory: SupCategory
  "If filters are applied, this will contain display information"
  appliedFilters: [SupAppliedFilter!]!
}

"A company with offers for a given part"
type SupPartSeller {
  "Cache ID"
  _cacheId: String!
  "The distributor"
  company: SupCompany!
  "Distributor's country"
  country: String
  "List of offers.  Multiple offers may exist in different packaging.\nWhile multiple geo-targeted offers may exist, currently the API only exposes one geo-targeted offer at a time based on `country` parameter.\nPlease contact us if you have a need to see all geo-targeted offer variants."
  offers: [SupOffer!]!
  "True if the distributor is an authorized distributor for this manufacturer.  See [authorized](https:\/\/octopart.com\/authorized) for more information."
  isAuthorized: Boolean!
  "True if the distributor is a Non-Authorized Dealer.  See [authorized](https:\/\/octopart.com\/authorized) for more information."
  isBroker: Boolean!
  "True if you can request a quote from this seller."
  isRfq: Boolean!
  "List of countries the seller ships to. An empty list represents zero shipping restrictions."
  shipsToCountries: [SupCountry!]!
}

"A Part can be a member of a PartSeries, which represents a product line or \"family\" of parts from the manufacturer.\n\nSee [series](https:\/\/octopart.com\/series) page for examples."
type SupPartSeries {
  "Octopart internal ID for this series"
  id: ID!
  "Name of the part series"
  name: String!
  "Octopart URL for this series, specific to the parent part"
  url: String!
}

"Price in a specific currency + quantity.  By supplying a `currency` parameter the API will populate an estimated convertedPrice in the user's desired currency."
type SupPricePoint {
  "Cache ID"
  _cacheId: String!
  "Minimum purchase quantity to get this price (aka price break)"
  quantity: Int!
  "Price in currency"
  price: Float!
  "Currency for price"
  currency: String!
  "Price converted to user's currency using foreign exchange rates.\n\nSince this is an estimate, an indicator should be shown to user if currency != convertedCurrency."
  convertedPrice: Float!
  "Currency for `convertedPrice`.  Will match value of `currency` argument."
  convertedCurrency: String!
  "The exchange rate used to calculate convertedPrice"
  conversionRate: Float!
}

type SupReferenceDesign {
  name: String!
  url: String!
}

"Represents a specific value of an Attribute for a given Part"
type SupSpec {
  attribute: SupAttribute!
  "The formatted display value"
  displayValue: String!
}

type SupSpecAgg {
  attribute: SupAttribute!
  buckets: [SupSpecBucket!]!
  "min is the lowest spec value in this result set for numerical attributes"
  min: Float
  "max is the greatest spec value in this result set for numerical attributes"
  max: Float
  "displayMin is the formatted string of min"
  displayMin: String
  "displayMax is the formatted string of max"
  displayMax: String
}

type SupSpecBucket {
  "displayValue is the string value. For numerical attributes it is the formatted version of floatValue"
  displayValue: String!
  "floatValue is populated if the attribute is numeric"
  floatValue: Float
  "count will be null if aggregation timed out"
  count: Int
}

type SupSpellingCorrection {
  correctionString: String!
  hits: Int!
}

"Part identified by manufacturer as being a companion part, for instance a mated connector pair."
type SupSponsoredPart {
  "Cache ID"
  _cacheId: String!
  ppid: ID! @deprecated(reason: "use part.id instead")
  sourceId: ID! @deprecated(reason: "unused")
  "Related part"
  part: SupPart!
  "URL to visit for related part"
  url: String!
}

"Suggests a query based on partial query input.  Used for autocomplete \/ typeahead UIs."
type SupSuggestion {
  "Suggested text of longer query"
  text: String!
  "If the suggestion should also apply a categoryId filter, this is the category name"
  inCategoryName: String!
  "If the suggestion should also apply a categoryId filter, this is the Category ID"
  inCategoryId: String!
}

input SupApiCredentials {
  "The name of the API that you are providing credentials for. An Octopart representative will give this value to you if needed."
  apiName: String!
  "Authentication details. `clientId` and `clientSecret` should be given together when an API requires them."
  clientId: String
  "Authentication details. `clientId` and `clientSecret` should be given together when an API requires them."
  clientSecret: String
  "Authentication details. `username` and `password` should be given together when an API requires them."
  username: String
  "Authentication details. `username` and `password` should be given together when an API requires them."
  password: String
}

input SupPartMatchOptions {
  "If true, only parts with at least one authorized seller will be returned."
  requireAuthorizedSellers: Boolean = false
  "If true, only parts with stock available will be returned."
  requireStockAvailable: Boolean = false
  "a key: value map of filters. See [filter values](\/api\/v4\/values#filters)"
  filters: Map
}

input SupPartMatchQuery {
  mpn: String
  sku: String
  mpnOrSku: String
  manufacturer: String
  seller: String
  start: Int! = 0
  limit: Int! = 3
  reference: String
}

enum SupPlanTier {
  FREE
  BASIC
  PRO
  ENTERPRISE
}

enum SupRole {
  DISTRIBUTOR
  CADMODELS
  INTERNAL
}

enum SupSortDirection {
  asc
  desc
}

"The name scalar represents a valid GraphQL name as specified in the spec and can be used to refer to fields or types."
scalar Name

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"The built-in `Decimal` scalar type."
scalar Decimal

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

directive @BlockAll(roles: [SupRole!]!) on FIELD_DEFINITION

directive @HasPlanTier(tier: SupPlanTier!) on FIELD_DEFINITION

directive @RequireAny(roles: [SupRole!]!) on FIELD_DEFINITION

"Delegates a resolver to a remote schema."
directive @delegate("The path to the field on the remote schema." path: String "The name of the schema to which this field shall be delegated to." schema: Name!) on FIELD_DEFINITION

directive @computed("Specifies the fields on which a computed field is dependent on." dependantOn: [Name!]) on FIELD_DEFINITION

"Annotates the original name of a type."
directive @source("The original name of the annotated type." name: Name! "The name of the schema to which this type belongs to." schema: Name!) repeatable on ENUM | OBJECT | INTERFACE | UNION | INPUT_OBJECT | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM_VALUE